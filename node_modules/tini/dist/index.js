const e=new class{constructor(){this.injectors=new Map}define(e,t){if(this.injectors.has(e))throw new Error("Cannot redefine existing injector "+e);return this.injectors.set(e,t),this}resolve(e,t){const s=this.injectors.get(e);if(s)return s(t);throw new Error("Cannot inject nonexisting dependency "+e)}},t=Symbol("dependencies"),s=Symbol("requirements");function n(n){var r,o;return o=class extends n{constructor(){super(),this[r]={},this.constructor[s].forEach(s=>{"string"==typeof s?this[t][s]=e.resolve(s):this[t][s.name]=e.resolve(s.name,s.data)})}static get[s](){return[]}},r=t,o}const r=t,o=s,i=/(\{\{([^\{|^\}]+)\}\})/gi,c=e=>{let t;const s=[],n=/(this\.[\w+|\d*]*)+/gi;for(;t=n.exec(e);)s.push(t[1]);return{paths:s,expression:e,expressions:s.length&&e.match(i)||[]}};const a=new class{constructor(){this.directives=new Set}register(e){this.directives.add(e)}getDirectives(){return Array.from(this.directives)}},u=(e,t,s)=>{s[e]?s[e].push(t):s[e]=[t]},d=(e,t,s=[])=>{const n=a.getDirectives().concat(s),r={},o=(e=>t=>{Object.keys(e).forEach(s=>{("*"===t||s.startsWith("this."+t))&&e[s].forEach(e=>{try{return e()}catch(e){return}})})})(r),i=document.createTreeWalker(e,NodeFilter.SHOW_ELEMENT|NodeFilter.SHOW_TEXT);let d;for(;d=i.nextNode();){if(d.nodeType===Node.ELEMENT_NODE){Array.from(d.attributes).forEach(e=>{const{expression:s,paths:o}=c(e.nodeValue||"");if(n.forEach(n=>{if(typeof n.attribute===e.nodeName||n.attribute(e)){requestAnimationFrame(()=>{e.ownerElement.removeAttribute(e.nodeName)});const i=n.process({attribute:e,expression:s,paths:o,componentNode:t,targetNode:e.ownerElement});if(i){const e=new Function(`return (${(s||"").slice(2,-2)});`);o.forEach(s=>{u(s,()=>{const s=e.call(t);i(s)},r)})}}}),(e.nodeValue||"").includes("{{")&&s)if(e.nodeName.startsWith("on")){const n=e.nodeName.slice(2),r=new Function("event",s.slice(2,-2)+";");t.removeAttribute(e.nodeName),d["on"+n]=e=>{r.call(t,e)}}else o.forEach(n=>{const o=new Function(`return ${s.slice(2,-2)};`);u(n,()=>e.nodeValue=String(o.call(t)),r)})});continue}if(!(d.nodeValue||"").includes("{{"))continue;const{expression:e,expressions:s,paths:o}=c(d.nodeValue||"");if(e){const e=d.nodeValue||"",n=s.reduce((e,t)=>(e[t]=new Function(`return ${t.slice(2,-2).trim()};`),e),{}),i=d,c=()=>Object.keys(n).reduce((e,s)=>{try{const r=n[s].call(t);let o=void 0===r?"":r;return e.split(s).join(o)}catch(t){return e.split(s).join("")}},e);o.forEach(e=>{u(e,()=>i.data=c(),r)})}}return{paths:Object.keys(r),update:o}},h=Symbol("ComponentMixinInternal");function l(e){return class extends e{constructor(){super(),this[h]={};const e=document.createElement("template");e.innerHTML=this.constructor.template;const t=e.content.cloneNode(!0),s=this.attachShadow({mode:"open"}),{paths:n,update:r}=d(t,this,[]);this[h].update=r,s.appendChild(t),requestAnimationFrame(()=>{n.forEach(e=>{const t=e.slice(5);let s=this[t];Object.defineProperty(this,t,{set:e=>{s=e,r(t)},get:()=>s}),r(t)})})}}}class p extends(l(HTMLElement)){constructor(){super()}requestUpdate(){requestAnimationFrame(()=>{this[h].update("*")})}}const f=(e={},t={})=>({...e,...t});class m{constructor(e={}){this.interceptors=[],this.baseUrl=e.baseUrl||"/",this.defaults=e.defaults||{},this.interceptors.push(e=>Promise.resolve(e))}async processResponse(e){let t=e;for(const e of this.interceptors)t=await e(t);return t}intercept(e){this.interceptors.push(e)}async post(e,t,s){let n=(await fetch(e,{method:"POST",...f(this.defaults,s),body:t})).json();return await this.processResponse(n)}async get(e,t={}){const s=await fetch(this.baseUrl+e,f(this.defaults,t));let n=await s.json();return await this.processResponse(n)}async put(e,t,s={}){return this.post(e,t,{method:"PUT",...s})}async delete(e,t,s={}){return this.post(e,t,{method:"DELETE",...s})}}const E=Symbol("HttpJson");e.define(E,e=>new m(e));a.register({attribute:e=>e.nodeName.startsWith("[")&&e.nodeName.endsWith("]"),process:({targetNode:e,attribute:t})=>{const s=t.nodeName.slice(1,-1).replace(/-([a-z])/g,(function(e){return e[1].toUpperCase()}));return t=>{e[s]=void 0!==t?t:""}}});a.register({attribute:e=>"#ref"===e.nodeName,process:({targetNode:e,componentNode:t,attribute:s})=>{const n=s.nodeValue;if("string"==typeof n){const s=t;s.$=s.ref={...s.ref||{},[n]:e}}t.requestUpdate()}});export{p as Component,l as ComponentMixin,n as DependenciesMixin,E as HttpJson,e as Injector,r as dependencies,o as requirements};
